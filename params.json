{
  "name": "Scala-Pact",
  "tagline": "A Scala implementation of CDC using the Pact standard",
  "body": "# ScalaPact\r\nA library for generating Consumer Driven Contract files in Scala projects following the PACT standard using [ScalaTest](http://www.scalatest.org/). Includes supporting tools that use Pact files to verify and stub services.\r\n\r\nScalaPact is intended for Scala developers who are looking for a better way to manage the HTTP contracts between their services.\r\n\r\n## Acknowledgments\r\nScalaPact is not an original idea - this project would never have happened without those who came before us:\r\n\r\n1. [DiUS](https://github.com/DiUS)\r\n1. [Pact Foundation](https://github.com/pact-foundation)\r\n1. [Thoughtworks / Ian Robinson / Martin Fowler](http://martinfowler.com/articles/consumerDrivenContracts.html)\r\n\r\nOf particular note is [Beth Skurrie](https://github.com/bethesque) - a lot of the design choices and ideas in ScalaPact are direct copies of the ones in her projects. If you're looking for a Ruby implementation, look no further!\r\n\r\n## Change Log\r\nUpdates and information about changes made between releases can be found in the [change log](https://github.com/ITV/scala-pact/blob/master/CHANGELOG.md). \r\n\r\n## Setup Guide\r\n\r\n### ScalaTest Library\r\nAdd the dependency to your `build.sbt` file like this:\r\n\r\n```\r\nlibraryDependencies ++= Seq(\r\n  \"com.itv\" %% \"scalapact-scalatest\" % \"1.0.2\" % \"test\"\r\n)\r\n```\r\n\r\n### SBT Plugin\r\nAdd the plugin to your `project/plugins.sbt` file like this:\r\n\r\n```\r\naddSbtPlugin(\"com.itv.plugins\" % \"scalapact-plugin\" % \"1.0.2\")\r\n```\r\n\r\n## Basic Usage Examples\r\n### ScalaTest Pact Forger API\r\nThere is an example test spec that can be found [here](https://github.com/ITV/scalapact/blob/master/scalapact-scalatest/src/test/scala/com/itv/scalapact/ExampleSpec.scala). The hope is that this will be a living example spec.\r\n\r\n### SBT Plugin Commands\r\n\r\n### pact-test\r\nYou can run the Pact test cases just by executing `sbt test` as normal. Because of the way the library has been written, running the tests will generate a series of Pact JSON files, one for each interaction.\r\n\r\nThe generated Pact files will be output to your target directory under `<project root>/target/pacts`.\r\n\r\nUsually it is desirable to condense the Pact files into one file per consumer / provider pair that contains all of the possible interactions.\r\n\r\nEntering `sbt pact-test` will:\r\n\r\n1. Run clean to remove any lingering pact files\r\n1. Run the tests as normal to generate the Pact files\r\n1. Squash the Pact files into one per consumer / provider pair\r\n\r\n### pact-stubber\r\nIn order to test your service in isolation, you'll need to be able to stub out your service's upstream dependancies. Luckily, you've already defined all the behaviours you expect your provider to exhibit in your CDC Pact tests!\r\n\r\nRunning `sbt pact-stubber` will re-run your Pact tests and then use the generated Pact files to create a running stub service. The stub will accept requests and deliver the responses you defined in your test cases giving you predictable, maintainable behaviour.\r\n\r\nYou can also run the stubber using a combination of the following command line options, below are the defaults:\r\n\r\n`sbt \"pact-stubber --host localhost --port 1234 --source target/pacts\"`\r\n\r\n*Note that files in the source folder are recursively loaded.*\r\n\r\n#### HTTP Administration\r\nIf you prefer, you can use the stubber dynamically by adding and removing pacts using HTTP. All calls must be made with a special header:\r\n\r\n`X-Pact-Admin=true`\r\n\r\n- `GET /interactions` returns a list of all currently loaded interactions\r\n- `POST | PUT /interactions` accepts a Pact JSON string and adds all the interactions to the pool it matches against\r\n- `DELETE /interactions` Clears all the current interactions so you can start again\r\n\r\n### pact-publish\r\nIf you plan to use pact testing as part of your CI pipeline you'll probably want to be able to share pact files efficiently between builds. For example a consumer project's build generates a new version of the projects Pact files and they are then used during the providers CI build.\r\n\r\nTo achieve this we use the Ruby tool called Pact Broker (see below) and the publish command to update the files to it.\r\n\r\n#### Command Line Options\r\nBefore we can publish, we have to tell Scala-Pact where it can find a running instance of Pact Broker by adding the following line to either `build.sbt` or `pact.sbt`:\r\n\r\n`pactBrokerAddress := \"http://my-pact-broker:4321\"`\r\n\r\nYou can also specify the version you wish to publish under by adding:\r\n\r\n`pactContractVersion := \"1.0.0\"`\r\n\r\nIf you omit this variable or set it to an empty string, the main project version will be the version used to publish against.\r\n\r\nYou can then use the publish command to generate and upload your pact files to pact broker:\r\n\r\n`sbt pact-publish`\r\n\r\nNote that your Pact files will have the same version number as the normal project version defined in your `build.sbt` file, because you versioned that breaking API change - right?\r\n\r\nBy default, Scala-Pact does not allow you to publish pact files from SNAPSHOT versions of your project (but takes into account the pactContractVersion if set). This is because it can confuse pact brokers understanding of the latest contract. If you wish to enable this behaviour, add the following line to your `pact.sbt` file:\r\n\r\n`allowSnapshotPublish := true`\r\n\r\n### pact-verify\r\nOnce the consumer has defined the contract as CDC tests and exported them to Pact files, they'll deliver them to their provider. The provider then exercises their own API using the Pact files via a verifier.\r\n\r\nThe verifier is quite a simple idea: load a Pact file, make all the requests and compare all the responses to the expected ones.\r\n\r\nThe ScalaPact verifier can be run by entering `sbt pact-verify`.\r\n\r\nThe verifier will write out JUnit results to the `target/test-reports` directory in order to fail builds.\r\n\r\n#### Command Line Options\r\nYou can also run the verifier using a combination of the following command line options. Below are the defaults:\r\n\r\n`sbt \"pact-verify --host localhost --protocol http --port 1234 --source pacts\"`\r\n\r\n*Note that files in the source folder are recursively loaded. Specifying a local source folder takes precedence over loading remote files from Pact Broker (see below)*\r\n\r\n#### Verifying with Pact Broker during a CI build\r\nIf you're using the publish command to send files to Pact Broker, you'll also want to know how to verify against them in the provider project.\r\n\r\nTo do this, you need to add the following to either your `build.sbt` or `pact.sbt` file:\r\n\r\n```\r\npactBrokerAddress := \"http://my-pact-broker:4321\"\r\nproviderName := \"The Name Of This Service\"\r\nconsumerNames := Seq(\"Consumer A\", \"Consumer B\")\r\n```\r\n\r\nNote: The names are **keys** and all have to line up. Downstream services must publish with the same names that you use to retrieve against.\r\n\r\nYou then run verify as normal **without** specifying a local folder i.e.:\r\n\r\n`sbt \"pact-verify --host localhost --port 1234\"`\r\n\r\nThis causes the verifier to try and load it's Pacts from Pact Broker ahead of the normal verification process.\r\n\r\n### Other Considerations\r\n\r\n1. Mock servers can only understand an endpoint being in one state. Mostly that isn't a problem - if you want to create a Pact describing the look up of documents that result in a 200 or a 404 you simply look up two different documents. Where you have something like a `/status` endpoint that could come back in different states that you care about, you would have to be a bit creative, or not describe that behaviour in a pact contract.\r\n1. ScalaTest runs in parallel by default so even clearing the state of the stubber between tests could, and probably would, result in errors if you were using HTTP administration.\r\n\r\n## Provider States\r\nScalaPact currently offers limited support for provider states.\r\n\r\nSometimes, you need to warn your provider that a contract relies on the providing system being in a particular state. For example, your contract describes requesting a document resource via a GET request with the document's id as a query parameter. If you send the Pact contract to your provider, but that document id doesn't exist on their system, then verification will fail through no-ones fault.\r\n\r\nTo warn the provider about such requirements, we use provider states. In the tests these are simply strings in the `given()` method as below:\r\n\r\n```\r\nforgePact\r\n  .between(\"My Consumer\")\r\n  .and(\"Their Provider Service\")\r\n  .addInteraction(\r\n    interaction\r\n      .description(\"Fetching a specific ID\")\r\n      .given(\"Resource with ID 1234 exists\")\r\n      .uponReceiving(\"/document/lookup?id=1234\")\r\n      .willRespondWith(200, \"ID: 1234 Exists\")\r\n  )\r\n  .runConsumerTest { mockConfig =>\r\n\r\n    val result = SimpleClient.doGetRequest(mockConfig.baseUrl, endPoint, Map.empty)\r\n\r\n    result.status should equal(200)\r\n    result.body should equal(\"ID: 1234 Exists\")\r\n\r\n  }\r\n```\r\n[Example taken from the ExampleSpec test suite.](https://github.com/ITV/scalapact/blob/master/scalapact-scalatest/src/test/scala/com/itv/scalapact/ExampleSpec.scala)\r\n\r\nThe `given(\"Resource with ID 1234 exists\")` string is actually a key that the provider can hook into! It shows up in the Pact contract under the `providerState` field like this:\r\n\r\n```\r\n{\r\n  \"provider\" : {\r\n    \"name\" : \"Their Provider Service\"\r\n  },\r\n  \"consumer\" : {\r\n    \"name\" : \"My Consumer\"\r\n  },\r\n  \"interactions\" : [\r\n    {\r\n      \"providerState\" : \"Resource with ID 1234 exists\",\r\n      \"description\" : \"Fetching a specific ID\",\r\n      \"request\" : {\r\n        \"method\" : \"GET\",\r\n        \"path\" : \"/provider-state\",\r\n        \"query\" : \"id=1234\"\r\n      },\r\n      \"response\" : {\r\n        \"status\" : 200,\r\n        \"body\" : \"ID: 1234 Exists\"\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nOn the provider's side, before verification they can opt to take action on any of these keys by adding a `pact.sbt` file to the root of their Scala project. Here is an example of the contents, again taken from the example suite:\r\n\r\n```\r\nimport com.itv.scalapact.plugin.ScalaPactPlugin._\r\n\r\nproviderStates := Seq(\r\n  (\"Resource with ID 1234 exists\", (key: String) => {\r\n    println(\"Injecting key 1234 into the database...\")\r\n    // Do some work to ensure the system under test is\r\n    // in an appropriate state before verification\r\n    true\r\n  })\r\n)\r\n```\r\n\r\n*Notice it's the same string!*\r\n\r\nNow when the provider runs the verification, the function they wrote will be invoked prior to the relevant interaction being verified.\r\n\r\nThe providerStates settings object is a `Seq[(String, String => Boolean)]` where the first string is the `key` and the `String => Boolean` is a function you describe that simply takes the `key` and returns whether your code ran successfully or not.\r\n\r\nThe intention is to create helper objects in the future for running common tasks like executing shell scripts but at the moment the functions are pure Scala and it's up to you how you use them.\r\n\r\n## Pact File Distribution via Pact Broker\r\nDuring a build process you will need some mechanism for delivering the Pact files your consumer tests generate to your provider ready for verification.\r\n\r\nYou can do this any way you like, they are just JSON files after all, but we are currently exploring [pact-broker](https://github.com/bethesque/pact_broker). Pact Broker is a Ruby service that allows you to post and look up versioned Pact files.\r\n\r\n*An opinionated note on versioning:* Focus on versioning your API's not your Pact files! It can be handy to have versions of Pact files around but you should not be pushing a breaking API changes and communicating them to your provider with versioned Pact files. A breaking API change is a new API version. Theoretically your provider should always be able to ask for the latest Pact files for each API version and have confidence that they are correct.\r\n\r\n## Pact Tests vs Integration Tests\r\nTechnically, when you write a Pact test you are creating an integration test, in that:\r\n\r\n1. You write some client code to make the call to your provider;\r\n2. You then write a test using a mock that expects a request and gives a response to a real HTTP call;\r\n3. You check the results are what you expected.\r\n\r\nThe *purpose* of Pact and Integration tests is different though. A Pact test is there to describe the agreed contract between one service and another from the perspective of the consumer. An integration test can describe the relationship but not in a way that you can share with your provider for verification. Additionally Integration tests are good for testing failure cases where Pact tests are not.\r\n\r\nConsider these two statements:\r\n1. Pact tests define *what* the agreement between a consumer and a provider is\r\n2. Integration tests check *how* that agreement is implemented on the consumer side\r\n\r\nFor instance, you should use Pact tests for describing the agreement:\r\n\r\n1. Requesting data in a specific format from a provider\r\n1. Describing content negotiation\r\n1. How a provider would respond if it couldn't find the data you wanted\r\n\r\nYou could then build on that with integration tests:\r\n\r\n1. Checking what happens if the provider simply isn't there\r\n1. Network failures\r\n1. Timeouts\r\n1. Missing end points\r\n1. Badly formed responses\r\n\r\n## Help!\r\nDepending on the kind of help or support you need, there are a few places you can try:\r\n\r\n### I have a Scala-Pact feature request or bug to report\r\nHave a look around our [issues page](https://github.com/ITV/scala-pact/issues) to see if anyone else has raised a similar request. If not, please raise a new issue and we'll try and help.\r\n\r\nIf you're a developer and you're feeling brave and generous, feel free to submit a pull request and we'll always do our best to accept it. For more information, please read our [contributing](https://github.com/ITV/scala-pact/blob/master/CONTRIBUTING.md) file.\r\n\r\n### I'm looking for general information on Pact or CDC\r\nGood places to start are the official [pact.io](http://www.pact.io) website or this article on [CDC](http://martinfowler.com/articles/consumerDrivenContracts.html).\r\n\r\n### I have a question about using Scala-Pact or Pact\r\nPlease direct questions to the official [Pact support google group](https://groups.google.com/forum/#!forum/pact-support). As well as queries, we would love to hear feedback about your experiences with Scala-Pact and Pact generally.\r\n\r\nIf you're a developer looking to contribute or build a new Pact implementation there's a [group](https://groups.google.com/forum/#!forum/pact-dev) for that too!\r\n\r\n## Pact Specification Compliance Level\r\nCurrently ScalaPact is not 100% compliant with the official Pact specification. We plan to be but the library is still under active development. The roadmap to Pact compliance will be something like:\r\n\r\n1. Complete testing all tools against the official specification test cases. The only area of the specification that is believed to be incomplete is around the JSON body matching rules.\r\n1. Consolidate our processes with the official implementor's guide.\r\n\r\nOur intention is to eventually meet version 2 of the pact specification.\r\n\r\n## Motivation\r\n[Pact](https://github.com/realestate-com-au/pact) is an implementation of CDC testing ([Consumer Driven Contract testing](http://martinfowler.com/articles/consumerDrivenContracts.html)). There are other implementations like [Pacto](https://github.com/thoughtworks/pacto) and they vary slightly in how they interpret the testing process.\r\n\r\nFollowing the Pact interpretation of CDC, the process goes something like this:\r\n\r\n1. Write a piece of client code in a project that consumes a service and knows the details of how to connect to that provider.\r\n1. Write a real integration test for that client code that hits a mock, but also as a side effect emits a JSON file describing the relationship. This JSON file is your Pact contract file. Note that in Pact (not Pacto) it is owned by the consumer.\r\n1. During development of the consumer, the Pact file can be used to run a lightweight stub service that mimics the expected behavior of the provider. *Note: The provider need not even exist yet and the Pact files can form part of the providers design specification.*\r\n1. Give the generated Pact file to the team that build the provider, an upstream service you depend on. This Pact file tells the provider team both how you expect their API to behave and *which parts of their API are delivering value to you the consumer*.\r\n1. The provider then verifies the Pact by running the requests and responses described in the Pact file against their system.\r\n\r\nMost of the original tools for CDC testing have come out of the Ruby community but a full list of officially supported languages can be found on the [pact.io](http://docs.pact.io/) website.\r\n\r\nThe crucial point to appreciate is that the client code is written in your native language using your normal test framework, and therefore, your Pact integrations tests must also be written in your native language too!\r\n\r\nThe other uses of the Pact files, verification and stubbing are largely standalone processes that are language agnostic and so it's quite feasible to use the Ruby implementations if you prefer.\r\n\r\nThere is another implementation of the Pact integration test suite that is compatible with Scala and [Specs2](https://etorreborre.github.io/specs2/) called [Pact-JVM](https://github.com/DiUS/pact-jvm). Pact-JVM also supports other JVM languages like Java and Groovy. Scala-Pact has the same aims and adheres to the same standards but attempts to deliver a more Scala specific experience.\r\n\r\n## Scala Project Library Dependencies\r\nThe Pact integration test library itself depends on a range of Scala/Java libraries.\r\n\r\n### Http4s\r\n[Http4s](http://http4s.org/) powers ScalaPact's stubber.\r\n\r\n### Argonaut\r\n[Argonaut](http://argonaut.io/) is used to read and write the JSON Pact files.\r\n\r\n### WireMock\r\n[WireMock](http://wiremock.org/) is used to supply the mocks that ScalaPact runs the integration tests against.\r\n\r\n### ScalaTest\r\n[ScalaTest](http://www.scalatest.org/) is both our test suite of choice and the target for the ScalaPact implementation.\r\n\r\n### Scalaj-Http\r\n[Scalaj-Http](https://github.com/scalaj/scalaj-http) is used for quick synchronous HTTP calls.\r\n\r\n### Scalaz\r\n[Scalaz](https://github.com/scalaz/scalaz) is the glue that holds it all together.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}